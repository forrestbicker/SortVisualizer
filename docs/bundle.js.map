{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/framework/ASorter.ts","webpack:///./src/Utility/Util.ts","webpack:///./src/app.ts","webpack:///./src/framework/SortingTask.ts","webpack:///./src/framework/TrackableArray.ts","webpack:///./src/SortingAlgorithms/MergeSort.ts","webpack:///./src/SortingAlgorithms/InsertionSort.ts","webpack:///./src/SortingAlgorithms/HeapSort.ts","webpack:///./src/Utility/TreeUtil.ts","webpack:///./src/framework/ArrayDrawer.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","sortingTask","this","task","execute","randomize","sort","drawer","display","verify","ASorter","UpdateType","COUNTER","POSITION","READER","copyOf","arr","out","push","subarray","start","end","max","length","Util","sorts","merge","MergeSort","insertion","InsertionSort","heapSort","HeapSort","htmlString","sortName","dropdown","document","getElementById","innerHTML","addEventListener","ArrayDrawer","selectedSort","SortingTask","array","setPrimaryArrayLength","tArr","TrackableArray","auxiliaryArrs","Array","generateNewAuxArr","getData","cutoff","randIx","Math","trunc","random","temp","isAux","acsesses","modifications","ix","pushCounterUpdate","set","pushPositionUpdate","pop","swap","a","b","tmp","getLength","setCounter","setPositions","toString","String","mergeSort","mid","left","right","k","leftValue","rightValue","j","convertToMaxHeap","maxHeapify","TreeUtil","getLeftChild","getRightChild","getRoot","getParrent","counterCanvas","posCanvas","readerCanvas","currentLength","currentMax","canvasWidth","canvasHeight","cWidthUnit","cHeightUnit","updateStack","resizeCanvas","width","height","setAttribute","newInnerHTML","Number","getAttribute","setReader","type","delay","len","setTimeout","displayNext","update","shift","undefined"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { SortingTask } from \"./SortingTask\"\n\nexport abstract class ASorter {\n    task: SortingTask;\n\n    constructor(sortingTask: SortingTask) {\n        this.task = sortingTask;\n    }\n\n    abstract sort(): SortingTask;\n\n    // display(): number {\n    //     this.dummy.textContent = \"boo\"\n    //     setInterval(function (task: SortingTask) { task.updateCanvas() }, 20, this.task);\n    //     return 0;\n    // }\n\n    execute(): void {\n        this.task.randomize();\n        this.sort();\n        // this.task.drawer.stopDisplayLoop();\n        this.task.drawer.display(15);\n        // this.task.tArr.display();\n        // clearInterval(id); // stops display loop\n    }\n\n    verify(): number {\n        return 0 // for sorted, 1 for not sorted\n    }\n}\n\n","export const UpdateType = {\n    COUNTER: 0,\n    POSITION: 1,\n    READER: 2,\n}\nexport class Util {\n\n\n    static copyOf(arr: number[]): number[] {\n        let out: number[] = [];\n        for (const n of arr) {\n            out.push(n);\n        }\n        return out;\n    }\n\n    static subarray(arr: number[], start: number, end: number) {\n        let out: number[] = [];\n        for (var i = start; i <= end; i++) {\n            out.push(arr[i]);\n        }\n        return out;\n    }\n\n    static max(arr: number[]): number {\n        let max: number = arr[0];\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n}","import { SortingTask } from \"./framework/SortingTask\";\nimport { ASorter } from \"./framework/ASorter\";\nimport { MergeSort } from \"./SortingAlgorithms/MergeSort\";\nimport { InsertionSort } from \"./SortingAlgorithms/InsertionSort\";\nimport { HeapSort } from \"./SortingAlgorithms/HeapSort\";\nimport { ArrayDrawer } from \"./framework/ArrayDrawer\";\n\nvar sorts: { [id: string]: any } = {\n    merge: function (sortingTask: SortingTask): MergeSort {\n        return new MergeSort(sortingTask);\n    },\n    insertion: function (sortingTask: SortingTask): InsertionSort {\n        return new InsertionSort(sortingTask);\n    },\n    heapSort: function (sortingTask: SortingTask): HeapSort {\n        return new HeapSort(sortingTask);\n    },\n};\n\nlet htmlString: string = \"\";\nfor (const sortName in sorts) {\n    htmlString += `<option value='${sortName}'>${sortName}</option>`;\n}\n\nlet dropdown: HTMLSelectElement = document.getElementById(\n    \"algoSelect\"\n)! as HTMLSelectElement;\ndropdown.innerHTML = htmlString;\n\ndocument.getElementById(\"startButton\")!.addEventListener(\"click\", runSort);\n\nfunction runSort(): void {\n    // create arr\n    var arr: Array<number> = [];\n    for (var i = 1; i <= 32; i++) {\n        arr.push(i);\n    }\n    \n    // build drawer\n    let drawer = new ArrayDrawer(\n        document.getElementById(\"counter\")!,\n        document.getElementById(\"position\")!,\n        document.getElementById(\"reader\")!,\n    );\n\n    let selectedSort: string = dropdown.value;\n    var s: ASorter = sorts[selectedSort](new SortingTask(arr, drawer)); // TODO: make a register, on click cancel the sort\n    s.execute();\n}\n\n// // docum\n// //\n// // document!.getElementById('root')!.textContent = \"hello\"\n\n// // var sorts = {\n// //     mergeSort: function (sortingTask): SortingTask {\n// //         sortingTask.aux.r = [];\n// //         sortingTask.aux.l = [];\n\n// //         for (var i = 0; i < sortingTask.arr.length / 2; i++) {\n\n// //         }\n\n// //         return sortingTask;\n// //     },\n// // };\n","import { TrackableArray } from \"./TrackableArray\";\nimport { ArrayDrawer } from \"./ArrayDrawer\";\nimport { Util } from \"../Utility/Util\";\nexport class SortingTask {\n    tArr: TrackableArray;\n    auxiliaryArrs: Array<TrackableArray>;\n    drawer: ArrayDrawer;\n\n    // swaps: number;\n    // comparisons: number;\n\n    constructor(array: Array<number>, drawer: ArrayDrawer) {\n        this.drawer = drawer;\n        this.drawer.setPrimaryArrayLength(array.length, Util.max(array));\n\n        this.tArr = new TrackableArray(array, this.drawer, false);\n        this.auxiliaryArrs = new Array<TrackableArray>();\n        // this.comparisons = 0;\n\n    }\n\n    generateNewAuxArr(): TrackableArray {\n        this.auxiliaryArrs.push(new TrackableArray([], this.drawer, true));\n        return this.auxiliaryArrs[this.auxiliaryArrs.length - 1];\n    }\n\n    getData(): any { };\n\n    randomize(): void {\n        let cutoff: number = 0;\n\n        while (cutoff < this.tArr.arr.length) {\n            let randIx: number = cutoff + Math.trunc(Math.random() * (this.tArr.arr.length - cutoff));\n            let temp: number = this.tArr.arr[cutoff];\n            this.tArr.arr[cutoff] = this.tArr.arr[randIx];\n            this.tArr.arr[randIx] = temp;\n            cutoff++\n        }\n\n    }\n\n    // updateCanvas(): void {\n    //     // this.canvas.innerHTML = \"\";\n    //     // this.updatePositions();\n    //     // this.updateCounters();\n    //     this.canvas.innerHTML += \".\\n\"\n    // }\n\n    // updateCounters(): void {\n\n    //     let auxAcsesses: number = 0;\n    //     let auxModifications: number = 0;\n\n    //     for (const arr of this.auxiliaryArrs) {\n    //         auxAcsesses += arr.acsesses;\n    //         auxModifications += arr.modifications;\n    //     }\n\n    //     this.canvas.innerHTML += `<text x=\"20\" y=\"35\">\n    //     Acsesses     : ${this.tArr.acsesses}\n    //     Modifications: ${this.tArr.modifications}\n    //     Aux Acs's    : ${auxAcsesses}\n    //     Aux Mod's    : ${auxModifications}  \n    //     </text>`\n    // };\n\n    // updatePositions(): void {\n    //     for (var i = 0; i < this.tArr.arr.length; i++) {\n    //         let height: number = this.tArr.arr[i] * this.cHeightUnit;\n    //         this.canvas.innerHTML += `<rect\n    //         width=\"${this.cWidthUnit}\"\n    //         height=\"${height}\"\n    //         x=\"${i * this.cWidthUnit}\"\n    //         y=\"${Number(this.canvas.getAttribute(\"height\")) - height}\"></rect>`;\n    //     }\n\n    // };\n}","import { ArrayDrawer } from \"./ArrayDrawer\";\n\nexport class TrackableArray { // todo: make extend Array<number>, MAYBE THATS NOT DESIRABLE because then u have easy acsess to methods that wll not incements counters when called  \n\n    arr: Array<number>;\n    acsesses: number;\n    modifications: number;\n    drawer: ArrayDrawer;\n    isAux: boolean; // aux arrs are NOT drawable, primary arrs are, only one drawable arr should be active at a time\n\n    constructor(array: Array<number>, drawer: ArrayDrawer, isAux: boolean) {\n        this.arr = array;\n        this.acsesses = 0;\n        this.modifications = 0;\n\n\n        this.isAux = isAux;\n\n        this.drawer = drawer;\n    }\n\n    get(ix: number): number {\n        this.acsesses++;\n        this.drawer.pushCounterUpdate(this);\n        return this.arr[ix];\n    }\n\n    set(ix: number, value: number): void {\n        this.arr[ix] = value;\n\n        this.modifications++;\n        this.drawer.pushCounterUpdate(this);\n        this.drawer.pushPositionUpdate(this);\n\n        // if (!this.isAux) {\n        //     console.log(this.modifications);\n        // }\n    }\n\n    push(value: number): void {\n        this.arr.push(value);\n\n        this.modifications++;\n        this.drawer.pushCounterUpdate(this);\n        this.drawer.pushPositionUpdate(this);\n    }\n\n    // remove(ix: number): void {\n    //     this.arr.\n    // }\n\n    pop(): void {\n        this.arr.pop();\n\n        this.modifications++;\n        this.drawer.pushPositionUpdate(this);\n    }\n\n    swap(a: number, b: number): void { // added layer of abstraction above normal functions\n        let tmp = this.get(a);\n        this.set(a, this.arr[b]);\n        this.set(b, tmp); // TODO: express tmp as an aux arr (or add a O(1) register) for const space tracking\n    }\n\n    getLength(): number {\n        return this.arr.length;\n    }\n\n    display(): void {\n        this.drawer.setCounter(this.acsesses, this.modifications);\n        this.drawer.setPositions(this.arr);\n    }\n\n    toString(): String {\n        let out: String = \"[\";\n        out += String(this.arr[0]);\n        for (var i = 1; i < this.arr.length; i++) {\n            out += \", \";\n            out += String(i);\n        }\n        out += \"]\";\n        return out;\n    }\n}","import { ASorter } from \"../framework/ASorter\";\nimport { TrackableArray } from \"../framework/TrackableArray\";\nimport { SortingTask } from \"../framework/SortingTask\"\nimport { Util } from \"../Utility/Util\";\n\nexport class MergeSort extends ASorter {\n    sort(): SortingTask {\n        this.mergeSort(0, this.task.tArr.getLength() - 1);\n        return this.task;\n    }\n\n    mergeSort(start: number, end: number): void { // returns array of indicies\n        if (start < end) {\n            let mid: number = Math.trunc((start + end) / 2);\n\n            this.mergeSort(start, mid);\n            this.mergeSort(mid + 1, end);\n\n            this.merge(start, mid, end);\n        }\n    }\n\n    merge(start: number, mid: number, end: number): void {\n\n        // allocate memory to array coppies\n        let left: TrackableArray = this.task.generateNewAuxArr();\n        let right: TrackableArray = this.task.generateNewAuxArr();\n\n        // populate coppies\n        for (var i: number = start; i <= mid; i++) {\n            left.push(this.task.tArr.get(i));\n        }\n\n        for (var i: number = mid + 1; i <= end; i++) {\n            right.push(this.task.tArr.get(i));\n        }\n\n        // crawlers\n        let l: number = 0; // left goes up to and including mid\n        let r: number = 0; // right is everything right of mid\n        let k: number = start; // insertion point to main array\n\n        while (l + start <= mid && r + mid + 1 <= end) {\n            let leftValue: number = left.get(l);\n            let rightValue: number = right.get(r);\n            if (leftValue <= rightValue) {\n                this.task.tArr.set(k, leftValue);\n                l++;\n            } else {\n                this.task.tArr.set(k, rightValue);\n                r++;\n            }\n            k++;\n        }\n\n        while (l + start <= mid) {\n            this.task.tArr.set(k, left.get(l));\n            l++;\n            k++;\n        }\n\n        while (r + mid + 1 <= end) {\n            this.task.tArr.set(k, right.get(r));\n            r++;\n            k++;\n        }\n    }\n\n}","import { ASorter } from \"../framework/ASorter\";\nimport { SortingTask } from \"../framework/SortingTask\"\n\n// n^2\nexport class InsertionSort extends ASorter {\n    sort(): SortingTask {\n        for (var i = 1; i < this.task.tArr.getLength(); i++) {\n            let key = this.task.tArr.get(i);\n            let j = i - 1;\n            while (j >= 0 && key < this.task.tArr.get(j)) {\n                this.task.tArr.set(j + 1, this.task.tArr.get(j));\n                j--;\n            }\n            this.task.tArr.set(j + 1, key);\n        }\n        return this.task;\n    }\n    \n}","import { ASorter } from \"../framework/ASorter\";\nimport { TreeUtil } from \"../Utility/TreeUtil\";\nimport { TrackableArray } from \"../framework/TrackableArray\";\nimport { SortingTask } from \"../framework/SortingTask\"\n\nexport class HeapSort extends ASorter {\n    sort(): SortingTask {\n        return this.task;\n    }\n\n    convertToMaxHeap(): void {\n\n    }\n\n    maxHeapify(ix: number): void {\n        let left = TreeUtil.getLeftChild(this.task.tArr, ix);\n        let right = TreeUtil.getRightChild(this.task.tArr, ix);\n\n\n    }\n}","import { TrackableArray } from \"../framework/TrackableArray\";\n\nexport class TreeUtil {\n\n    static getRoot(arr: TrackableArray): number {\n        return arr.get(0);\n    }\n\n    static getLeftChild(arr: TrackableArray, ix: number) {\n        return arr.get(ix / 2);\n    }\n\n    static getRightChild(arr: TrackableArray, ix: number) {\n        return arr.get(ix / 2 + 1);\n    }\n\n    static getParrent(arr: TrackableArray, ix: number) {\n        return arr.get(2 * (ix - ix % 2));\n    }\n}","import { TrackableArray } from \"./TrackableArray\";\nimport { Util, UpdateType } from \"../Utility/Util\";\n\nexport class ArrayDrawer { // TODO: each sorting tash should have an array drawer that is passed down and can tell aux from primary on method call\n\n    counterCanvas: Element;\n    posCanvas: Element;\n    readerCanvas: Element;\n\n    currentLength: number = 0;\n    currentMax: number = 0;\n\n    canvasWidth: number = 0;\n    canvasHeight: number = 0;\n\n    cWidthUnit: number = 0;\n    cHeightUnit: number = 0;\n\n    updateStack: any[];\n\n\n    constructor(counterCanvas: HTMLElement, posCanvas: HTMLElement, readerCanvas: HTMLElement) { // TODO: condense p and aux arrays to one, canvas will be null for aux, additional struct param: counter loc, will write all counter updates there and all pos update to canvas (which is null for aux cuz no need to update pos for aux)\n        this.counterCanvas = counterCanvas;\n        this.posCanvas = posCanvas;\n        this.readerCanvas = readerCanvas;\n\n        this.updateStack = [];\n\n        this.updateStack = [];\n\n        this.resizeCanvas(500, 500);\n    }\n\n    resizeCanvas(width: number, height: number): void {\n        this.canvasWidth = width;\n        this.canvasHeight = height;\n\n        this.posCanvas.setAttribute(\"width\", String(this.canvasWidth));\n        this.posCanvas.setAttribute(\"height\", String(this.canvasHeight));\n\n        this.setPrimaryArrayLength(this.currentLength, this.currentMax);\n    }\n\n    setPrimaryArrayLength(length: number, max: number): void {\n        this.currentLength = length;\n        this.cWidthUnit = 1.0 * this.canvasWidth / length; // assumes len = max - 1 (true if is consecuitive range of ints)\n        this.cHeightUnit = 1.0 * this.canvasHeight / max; // \n    }\n\n\n    setCounter(acsesses: number, modifications: number): void {\n        this.counterCanvas.innerHTML = `\n        <text x=\"20\" y=\"35\">\n        Acsesses     : ${acsesses}\n        <br>\n        Modifications: ${modifications}\n        </text>`\n\n    }\n\n    setPositions(arr: number[]): void { // todo: fix all array<number> to number<> and the likes\n        let newInnerHTML: string = \"\"\n        let canvasHeight: number = Number(this.posCanvas.getAttribute(\"height\"));\n        for (var i = 0; i < arr.length; i++) {\n            let height: number = arr[i] * this.cHeightUnit;\n            newInnerHTML += `\n                <rect\n                width=\"${this.cWidthUnit}\"\n                height=\"${height}\"\n                x=\"${i * this.cWidthUnit}\"\n                y=\"${canvasHeight - height}\">\n                </rect>`;\n        }\n        this.posCanvas.innerHTML = newInnerHTML;\n    }\n\n    setReader(ix: number): void {\n        this.posCanvas.innerHTML = \"\";\n    }\n\n    pushCounterUpdate(tArr: TrackableArray): void { // TODO: insteead of taking arguments, make two incrementors for the 2 vars that redir to setCounter, learn how to locate a div from within the canvas, then with that read its text conent, and asign it ot 1 + that number\n        this.updateStack.push({\n            type: UpdateType.COUNTER,\n            isAux: tArr.isAux,\n            acsesses: tArr.acsesses,\n            modifications: tArr.modifications\n        });\n    };\n\n    pushPositionUpdate(tArr: TrackableArray): void { // TODO: this gets wierd slightly when u pop an element, instead we should try to restrict to only switches NOPE, because non comparison-only paragrims exist, i.e. radix sort\n        if (!tArr.isAux) {\n            this.updateStack.push({\n                type: UpdateType.POSITION,\n                arr: Util.copyOf(tArr.arr)\n            });\n        }\n    };\n\n    // startDisplayLoop(delay: number): void {\n    //     this.stopDisplayLoop();\n    //     this.intervalID = setInterval(this.displayNext, delay)\n    // }\n\n    // stopDisplayLoop() {\n    //     clearInterval(this.intervalID!);\n    // }\n\n    display(delay: number): void {\n        let len: number = this.updateStack.length;\n        for (var i = 0; i < len; i++) {\n            setTimeout(() => { this.displayNext() }, i * delay);\n        }\n    }\n\n    displayNext(): void {\n        let update = this.updateStack.shift(); // FIFO queue\n        if (update != undefined) {\n            switch (update.type) { // TODO: doing this as arrs works okay but would be better to do as dictionaries\n                case UpdateType.COUNTER:\n                    if (update.isAux) { // if is is an aux arr\n                        // this.setCounter(0, 0);\n                    } else {\n                        this.setCounter(update.acsesses, update.modifications);\n                    }\n                    break;\n\n                case UpdateType.POSITION:\n\n                    this.setPositions(update.arr);\n                    break;\n\n                case UpdateType.READER:\n                    break;\n            }\n        }\n    }\n\n\n    // TODO: idea of drawing directly to screen is moot beause way to slow. instead we will do new schedueler. it will work very well btu thte only problem is that it has high waiting time because must sort whole array first but bopefully if computers are fast enugh it should take less than 1 seccond. i think this will do well actually. we just push every frame into a stack and then we can do a loop to scheudel them at delayed intervals.\n}"],"sourceRoot":""}